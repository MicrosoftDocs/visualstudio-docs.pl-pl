---
title: 'CA1062: Waliduj argumenty metod publicznych'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1062
- ValidateArgumentsOfPublicMethods
- Validate arguments of public methods
helpviewer_keywords:
- CA1062
- ValidateArgumentsOfPublicMethods
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 2c224712305a1342f7af137885780b59d2c995a6
ms.sourcegitcommit: de98ed7edc81383e47b87ae6e61143fbbbe7bc56
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/21/2020
ms.locfileid: "88710965"
---
# <a name="ca1062-validate-arguments-of-public-methods"></a>CA1062: Waliduj argumenty metod publicznych

|Element|Wartość|
|-|-|
|CheckId|CA1062|
|Kategoria|Microsoft. Design|
|Zmiana podziału|Nieprzerwanie|

## <a name="cause"></a>Przyczyna

Widoczna na zewnątrz Metoda odwołuje się do jednego z argumentów odwołania bez weryfikowania, czy ten argument jest `null` ( `Nothing` w Visual Basic).

Następujące aspekty tej reguły [można konfigurować](#configurability):
* Określa, czy należy analizować metodę rozszerzenia "This".
* Określ metody sprawdzania poprawności sprawdzenia wartości null w przywoływanych bibliotekach lub projektach, które sprawdzają, czy argumenty przekazane do niego są inne niż null.
* Części bazy kodu do wykluczenia z analizy.

## <a name="rule-description"></a>Opis reguły

Wszystkie argumenty odwołania, które są przekazane do widocznych zewnętrznie metod, powinny być sprawdzane względem `null` . W razie potrzeby throw, <xref:System.ArgumentNullException> gdy argument ma wartość `null` .

Jeśli metodę można wywołać z nieznanego zestawu, ponieważ jest ona zadeklarowana jako publiczna lub chroniona, należy zweryfikować wszystkie parametry metody. Jeśli metoda jest przeznaczona do wywoływania tylko przez znane zestawy, należy wprowadzić metodę wewnętrzną i zastosować <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atrybut do zestawu, który zawiera metodę.

## <a name="how-to-fix-violations"></a>Jak naprawić naruszenia

Aby naprawić naruszenie tej reguły, sprawdź poprawność każdego argumentu odwołania względem `null` .

## <a name="when-to-suppress-warnings"></a>Kiedy pominąć ostrzeżenia

Możesz pominąć ostrzeżenie z tej reguły, jeśli masz pewność, że odwołanie do parametru zostało zweryfikowane przez inne wywołanie metody w funkcji.

## <a name="configurability"></a>Określając

Ta reguła ma następujące konfigurowalne opcje.

### <a name="exclude-extension-method-this-parameter"></a>Wyklucz metodę rozszerzenia "This"

Domyślnie ta reguła analizuje i flaguje `this` parametr dla metod rozszerzających. Możesz wykluczyć analizę `this` parametrów dla metod rozszerzających, dodając następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
dotnet_code_quality.CA1062.exclude_extension_method_this_parameter = true
```

### <a name="null-check-validation-methods"></a>Metody sprawdzania poprawności sprawdzania wartości null

Ta reguła może prowadzić do fałszywych wartości dodatnich, jeśli kod wywołuje specjalne metody sprawdzania poprawności sprawdzania wartości null w przywoływanych bibliotekach lub projektach. Można uniknąć tych fałszywych wartości dodatnich przez określenie nazwy lub sygnatury metod sprawdzania poprawności sprawdzenia wartości null.  Następnie analiza przyjmie, że argumenty przekazane do tej metody są inne niż null po wywołaniu. Na przykład aby oznaczyć wszystkie metody o nazwie `Validate` jako metody sprawdzania poprawności sprawdzenia wartości null, można dodać następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
dotnet_code_quality.CA1062.null_check_validation_methods = Validate
```

Dozwolone formaty nazw metod w wartości opcji (oddzielone znakiem "|"):
- Tylko nazwa metody (zawiera wszystkie metody o nazwie, niezależnie od typu zawierającego lub przestrzeni nazw)
- W pełni kwalifikowane nazwy w [formacie identyfikatora dokumentacji](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu z opcjonalnym `M:` prefiksem.

Przykłady:

| Wartość opcji | Podsumowanie |
| --- | --- |
|`dotnet_code_quality.CA1062.null_check_validation_methods = Validate` | Dopasowuje wszystkie metody o nazwie "Validate" w kompilacji
|`dotnet_code_quality.CA1062.null_check_validation_methods = Validate1|Validate2` | Dopasowuje wszystkie metody o nazwie "Validate1" lub "Validate2" w kompilacji
|`dotnet_code_quality.CA1062.null_check_validation_methods = NS.MyType.Validate(ParamType)` | Dopasowuje określoną metodę "Validate" przy użyciu podanego w pełni kwalifikowanego podpisu
|`dotnet_code_quality.CA1062.null_check_validation_methods = NS1.MyType1.Validate1(ParamType)|NS2.MyType2.Validate2(ParamType)` | Dopasowuje określone metody "Validate1" i "Validate2" z odpowiednimi w pełni kwalifikowanymi sygnaturami

### <a name="excluded-symbol-names"></a>Wykluczone nazwy symboli

Można skonfigurować, które części bazy kodu mają być wykluczone z analizy. Na przykład aby określić, że reguła nie powinna być uruchamiana na żadnym kodzie w typach o nazwie `MyType` , Dodaj następującą parę klucz-wartość do pliku editorconfig w projekcie:

```ini
dotnet_code_quality.CA1062.excluded_symbol_names = MyType
```

Dozwolone formaty nazw symboli w wartości opcji (oddzielone znakiem "|"):
- Tylko nazwa symbolu (zawiera wszystkie symbole z nazwą, niezależnie od typu zawierającego lub przestrzeni nazw)
- W pełni kwalifikowane nazwy w [formacie identyfikatora dokumentacji](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)symbolu. Każda nazwa symbolu wymaga prefiksu rodzaju symboli, takiego jak "M:" prefix dla metod, "T:" prefiksu dla typów, "N:" prefiksu dla przestrzeni nazw itd.
- `.ctor` dla konstruktorów i `.cctor` dla konstruktorów statycznych

Przykłady:

| Wartość opcji | Podsumowanie |
| --- | --- |
|`dotnet_code_quality.CA1062.excluded_symbol_names = MyType` | Dopasowuje wszystkie symbole o nazwie "MyType" w kompilacji
|`dotnet_code_quality.CA1062.excluded_symbol_names = MyType1|MyType2` | Dopasowuje wszystkie symbole o nazwie "MyType1" lub "MyType2" w kompilacji
|`dotnet_code_quality.CA1062.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Dopasowuje określoną metodę "nomethod" przy użyciu podanego w pełni kwalifikowanego podpisu
|`dotnet_code_quality.CA1062.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Dopasowuje określone metody "MyMethod1" i "MyMethod2" z odpowiednimi w pełni kwalifikowanymi sygnaturami

Wszystkie te opcje można skonfigurować dla opcji tylko dla tej reguły, dla wszystkich reguł lub dla wszystkich reguł w tej kategorii (projekt). Aby uzyskać więcej informacji, zobacz [Konfigurowanie analizatorów jakości kodu platformy .NET](configure-fxcop-analyzers.md).

## <a name="example"></a>Przykład

Poniższy przykład pokazuje metodę, która narusza regułę i metodę, która spełnia kryteria.

```csharp
using System;

namespace DesignLibrary
{
    public class Test
    {
        // This method violates the rule.
        public void DoNotValidate(string input)
        {
            if (input.Length != 0)
            {
                Console.WriteLine(input);
            }
        }

        // This method satisfies the rule.
        public void Validate(string input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            if (input.Length != 0)
            {
                Console.WriteLine(input);
            }
        }
    }
}
```

```vb
Imports System

Namespace DesignLibrary

    Public Class Test

        ' This method violates the rule.
        Sub DoNotValidate(ByVal input As String)

            If input.Length <> 0 Then
                Console.WriteLine(input)
            End If

        End Sub

        ' This method satisfies the rule.
        Sub Validate(ByVal input As String)

            If input Is Nothing Then
                Throw New ArgumentNullException(NameOf(input))
            End If

            If input.Length <> 0 Then
                Console.WriteLine(input)
            End If

        End Sub

    End Class

End Namespace
```

## <a name="example"></a>Przykład

Konstruktory kopiujące wypełniające pola lub właściwości, które są obiektami odniesienia, mogą również naruszać regułę CA1062. Naruszenie występuje, ponieważ skopiowany obiekt, który jest przesyłany do konstruktora kopiującego, może być `null` ( `Nothing` w Visual Basic). Aby rozwiązać ten problem, należy użyć statycznej metody udostępnionej w Visual Basic), aby sprawdzić, czy skopiowany obiekt nie ma wartości null.

W poniższym `Person` przykładzie klasy `other` obiekt, który jest przesyłany do `Person` konstruktora kopiującego może być `null` .

```csharp
public class Person
{
    public string Name { get; private set; }
    public int Age { get; private set; }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Copy constructor CA1062 fires because other is dereferenced
    // without being checked for null
    public Person(Person other)
        : this(other.Name, other.Age)
    {
    }
}
```

## <a name="example"></a>Przykład

W poniższym, zmienionym `Person` przykładzie, `other` obiekt, który jest przesyłany do konstruktora kopiującego, jest najpierw sprawdzany pod kątem wartości null w `PassThroughNonNull` metodzie.

```csharp
public class Person
{
    public string Name { get; private set; }
    public int Age { get; private set; }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Copy constructor
    public Person(Person other)
        : this(PassThroughNonNull(other).Name, other.Age)
    {
    }

    // Null check method
    private static Person PassThroughNonNull(Person person)
    {
        if (person == null)
            throw new ArgumentNullException(nameof(person));
        return person;
    }
}
```
