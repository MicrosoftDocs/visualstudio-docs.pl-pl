---
title: Reguły wydajności według Identyfikatora | Dokumentacja firmy Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology: vs-ide-debug
ms.topic: conceptual
ms.assetid: 9a1c934c-4798-4df9-a8ef-eb17ef06b6a2
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 7b997c92dbc5205ec0001ac6d89829646bb01922
ms.sourcegitcommit: bccb05b5b4e435f3c1f7c36ba342e7d4031eb398
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/06/2018
ms.locfileid: "51221025"
---
# <a name="performance-rules-by-id"></a>Reguły wydajności według identyfikatora

| Ostrzeżenie | Opis |
| - | - |
| [DA0001: Użyj klasy StringBuilder do konkatenacji](../profiling/da0001-use-stringbuilder-for-concatenations.md) | Wywołania System.String.Concat są znaczna część danych profilowania. Należy rozważyć użycie <xref:System.Text.StringBuilder> klasy w celu tworzenia ciągów z więcej niż jednego segmentu. |
| [DA0002: Brak biblioteki VSPerfCorProf.dll](../profiling/da0002-vsperfcorprof-dll-is-missing.md) | Program profilujący nie można odnaleźć VSPerfCorProf.dll podczas uruchomienia profilowania. To ostrzeżenie występuje, gdy są używane narzędzia wiersza polecenia do zbierania danych profilera, bez użycia narzędzia VSPerfCLREnv.cmd, aby zainicjować zmienne środowiskowe wymagane. |
| [DA0003: Wiele przykładów jądra](../profiling/da0003-many-kernel-samples.md) | Znaczna część przykłady stosie wywołań zbieranych dla aplikacji zostały wykonywania w trybie jądra. Należy wziąć pod uwagę, profilowanie aplikacji przy użyciu innej metody profilowania. |
| [DA0004: Znaczące wykorzystanie procesora](../profiling/da0004-high-processor-usage.md) | Użycie procesora (CPU) czasu podczas profilowania danych, które zostały zebrane przy użyciu metody instrumentacji. Należy wziąć pod uwagę przy użyciu metody próbkowania, metoda profilowania, gdy profilowanie Procesora powiązana aplikacja. |
| [DA0005: Częste odzyskiwanie pamięci GC2](../profiling/da0005-frequent-gc2-collections.md) | Dużą liczbę obiektów pamięci platformy .NET są są odzyskiwane w generacji 2 wyrzucania elementów bezużytecznych. |
| [DA0006: Przesłoń metody Equals() dla typów wartości](../profiling/da0006-override-equals-parens-for-value-types.md) | Wywołania do metody Equals i operatory równości typu publicznego wartości są znaczna część danych profilowania. Rozważ zaimplementowanie bardziej efektywną metodę. |
| [DA0007: Unikanie używania wyjątków do przepływu sterowania](../profiling/da0007-avoid-using-exceptions-for-control-flow.md) | Wysoki współczynnik obsługi wyjątków w .NET Framework zostały wywołane w danych profilowania. Należy rozważyć użycie inną logikę przepływu sterowania w celu zmniejszenia liczby wyjątków, które są generowane. |
| [DA0008: Kilka zebranych próbek](../profiling/da0008-few-samples-collected.md) | Tylko kilka przykładów zostały zebrane podczas uruchomienia profilowania. Należy wziąć pod uwagę dłużej przebiegu lub zwiększenie częstotliwości próbkowania dla uzyskania bardziej znaczących wyników. |
| [DA0009: Wysoka wartość licznika % czasu w trybie JIT](https://msdn.microsoft.com/b60c1767-515c-41d9-81c2-c70d0b7024fd) | W kompilatorze tylko w czas (JIT) był poświęcony na znacznego procentu czasu wykonywania aplikacji. |
| [DA0010: Kosztowna funkcja GetHashCode](../profiling/da0010-expensive-gethashcode.md) | Wywołania metody GetHashCode tego typu są znaczna część danych profilowania, lub metoda przydziela pamięć. |
| [DA0011: Kosztowna funkcja CompareTo](../profiling/da0011-expensive-compareto.md) | CompareTo — metoda tego typu jest kosztowne lub przydziela pamięć. |
| [DA0012: Znaczne odbicie](../profiling/da0012-significant-amount-of-reflection.md) | Wywołania do metody System.Reflection, takie jak element InvokeMember i GetMember lub typ metod, takich jak MemberInvoke są znaczna część danych profilowania. Gdy to możliwe, należy wziąć pod uwagę zastąpienie tych metod wczesne powiązania do metod zestawów zależnych. |
| [DA0013: Znaczące wykorzystanie funkcji String.Split i String.Substring](../profiling/da0013-high-usage-of-string-split-or-string-substring.md) | Wywołania metod System.String.Split lub System.String.Substring są signifiicant część danych profilowania. Należy rozważyć użycie System.String.IndexOf lub System.String.IndexOfAny, jeśli testujesz istnienie podciągów w ciągu. |
| [DA0014: Skrajnie intensywne stronicowanie aktywnej pamięci na dysk](../profiling/da0014-extremely-high-rates-of-paging-active-memory-to-disk.md) | Dane o wydajności systemu, które zostały zebrane podczas uruchomienia profilowania wskazuje, że inwestują stopień stronicowania aktywnej pamięci na i z dysku wystąpiły w całym uruchomienia profilowania. Stawki stronicowania na tym poziomie, zwykle będzie miało wpływ na wydajność aplikacji i czasu odpowiedzi. Rozważ zmniejszenie alokacji pamięci przez modyfikowanie algorytmów. Może być również konieczne należy wziąć pod uwagę wymagania dotyczące pamięci aplikacji lub uruchomiony ponownie profilowanie na komputerze, który ma więcej pamięci. |
| [DA0017: Intensywne stronicowanie aktywnej pamięci na dysk](../profiling/da0017-high-rates-of-paging-active-memory-to-disk.md) | Dane o wydajności systemu, które zostały zebrane podczas uruchomienia profilowania wskazuje, że wysoki stopień stronicowania aktywnej pamięci na i z dysku wystąpiły w całym uruchomienia profilowania. Stawki stronicowania na tym poziomie, zwykle będzie miało wpływ na wydajność aplikacji i czasu odpowiedzi. Rozważ zmniejszenie alokacji pamięci przez modyfikowanie algorytmów. Może być również konieczne należy wziąć pod uwagę wymagania dotyczące pamięci aplikacji lub uruchomiony ponownie profilowanie na komputerze, który ma więcej pamięci. |
| [DA0018: Aplikacja 32-bitowa działa w granicach pamięci zarządzanej dla procesu](../profiling/da0018-32-bit-application-running-at-process-managed-memory-limits.md) | Dane systemowe, które zostały zebrane podczas uruchomienia profilowania wskazuje, że pamięci .NET Framework stosów skontaktowali się odpowiedni rozmiar najwyższy zarządzanej sterty może zwiększyć się w procesie 32-bitowym. Wartość zgłaszaną jest najwyższą wartość obserwowanych sterty, gdy trwa PROFILOWANEGO procesu była aktywna. Należy wziąć pod uwagę, optymalizacja wykorzystania zasobów zarządzanych przez aplikację. |
| [DA0021: Duża częstotliwość odzyskiwania pamięci generacji 1](../profiling/da0021-high-rate-of-gen-1-garbage-collections.md) | Dane o wydajności systemu, które zostały zebrane podczas profilowania wskazują, że znaczna część obiekty struktury for.NET pamięci zostało odzyskane w generacji 1 wyrzucania elementów bezużytecznych w porównaniu do generacji 0 danych kolekcji. |
| [DA0022: Duża częstotliwość odzyskiwania pamięci generacji 2](../profiling/da0022-high-rate-of-gen-2-garbage-collections.md) | Dane o wydajności systemu, które zostały zebrane podczas profilowania wskazują, że znaczna część obiekty struktury for.NET pamięci zostało odzyskane w generacji 2, wyrzucanie elementów bezużytecznych w porównaniu do generacji 0 i 1 wyrzucania generacji. |
| [DA0023: Duże zużycie czasu procesora CPU przez odzyskiwanie pamięci](../profiling/da0023-high-gc-cpu-time.md) | Dane o wydajności systemu, które zostały zebrane podczas profilowania wskazuje czas poświęcony na wyrzucanie elementów bezużytecznych jest istotne w porównaniu z czasu przetwarzania kompletnej aplikacji. |
| [DA0024: Nadmierne zużycie czasu procesora CPU przez odzyskiwanie pamięci](../profiling/da0024-excessive-gc-cpu-time.md) | Dane o wydajności systemu, które zostały zebrane podczas profilowania wskazuje czas poświęcony na wyrzucanie elementów bezużytecznych jest zbyt wysoka w porównaniu z czasu przetwarzania kompletnej aplikacji. |
| [DA0026: Nadmierne zużycie czasu procesora CPU w trybie jądra](../profiling/da0026-excessive-kernel-cpu-time-processing.md) | Czas procesora CPU udział, który został wykonany w trybie jądra była większa niż ilość czasu spędzonego w trybie użytkownika. Należy wziąć pod uwagę profilowanie ponownie i próbkowanie liczba wywołań systemowych (syscalls) w celu ustalenia przyczyny od czasu wykonania trybu jądra wysoka. |
| [DA0029: Nieobsługiwana wersja środowiska CLR](../profiling/da0029-unsupported-clr-version.md) | Próbujesz przeprowadzić profilowanie aplikacji przy użyciu platformy .NET Framework w wersji 1.1, która nie jest obsługiwana przez narzędzia profilowania. |
| [DA0030: Zbieraj pomiary interakcji warstw dla projektów bazy danych](../profiling/da0030-gather-tier-interaction-measurements-for-database-projects.md) | Wywołania <xref:System.Data> metody są znaczna część danych profilowania, a nie zostały zebrane dane interakcji między warstwami podczas uruchomienia profilowania. Należy wziąć pod uwagę profilowanie ponownie i dodawanie danych o interakcji między warstwami. |
| [DA0038: Wysoki współczynnik rywalizacji o blokadę](../profiling/da0038-high-rate-of-lock-contentions.md) | Dane wydajności systemu, które są zbierane przy użyciu danych profilowania wskazuje, że inwestują liczba rywalizacji blokad podczas wykonywania aplikacji. Należy wziąć pod uwagę, profilowanie, aby znaleźć przyczynę rywalizacji ponownie, używając metoda profilowania współbieżności. |
| [DA0039: Bardzo wysoki współczynnik rywalizacji o blokadę](../profiling/da0039-very-high-rate-of-lock-contentions.md) | Dane wydajności systemu, które są zbierane przy użyciu danych profilowania wskazuje, że zbyt wysoka liczba rywalizacji blokad podczas wykonywania aplikacji. Należy wziąć pod uwagę, profilowanie, aby znaleźć przyczynę rywalizacja ponownie, używając metoda profilowania współbieżności. |
| [DA0501: Średnie użycie procesora CPU przez profilowany proces](../profiling/da0501-average-cpu-consumption-by-the-process-being-profiled.md) | Ten komunikat raporty procent czasu procesor był zajęty, wykonując instrukcje z aplikacji. Wystąpienia wartości zgłoszonej jest średnią we wszystkich interwałach pomiarowych, w których była aktywna PROFILOWANEGO procesu. Wartość może być większa niż 100% na maszynie z więcej niż jednego procesora. |
| [DA0502: Maksymalne użycie procesora CPU przez profilowany proces](../profiling/da0502-maximum-cpu-consumption-by-the-process-being-profiled.md) | Ten komunikat raporty najwięcej czasu procesor był zajęty, wykonując instrukcje z aplikacji. Wystąpienia wartości zgłoszonej jest najwyższą wartość, które są zgłaszane wśród wszystkich interwałów pomiarowych, w których był aktywny proces poddawany profilowaniu. Wartość procentowa może być większa niż 100% na maszynie z więcej niż jednego procesora. |
| [DA0503: Średni zestaw roboczy w bajtach dla profilowanego procesu](../profiling/da0503-average-working-set-in-bytes-for-the-process-being-profiled.md) | Ten komunikat raporty średniej ilości pamięci fizycznej w bajtach (zestaw roboczy) aktualnie używanej przez proces. Proces Zestaw roboczy zawiera strony z przestrzeni adresowej procesu, które obecnie zajmują pamięci fizycznej. |
| [DA0504: Maksymalny zestaw roboczy w bajtach dla profilowanego procesu](../profiling/da0504-maximum-working-set-in-bytes-for-the-process-being-profiled.md) | Ten komunikat raporty największa ilość pamięci fizycznej w bajtach aktualnie używanej przez proces. Proces Zestaw roboczy zawiera strony z przestrzeni adresowej procesu, które obecnie zajmują pamięci fizycznej. Ta zasada zgłasza najwyższą wartość, aby uzyskać zestaw roboczy procesu podczas profilowania jest aktywny. |
| [DA0505: Średnia liczba bajtów prywatnych alokowanych dla profilowanego procesu](../profiling/da0505-average-private-bytes-allocated-for-the-process-being-profiled.md) | Ten komunikat raporty średniej ilości pamięci wirtualnej, która w bajtach (bajty prywatne) aktualnie przydzielonej przez proces. Bajty prywatne są lokalizacje pamięci wirtualnej, które zostały przydzielone przez proces, który może zostać oceniony jedynie przez działający proces wątki. |
| [DA0506: Maksymalna liczba bajtów prywatnych alokowanych dla profilowanego procesu](../profiling/da0506-maximum-private-bytes-allocated-for-the-process-being-profiled.md) | Ten komunikat raporty największa ilość pamięci wirtualnej, która w bajtach (bajty prywatne) aktualnie przydzielonej przez proces. Bajty prywatne są lokalizacje pamięci wirtualnej, które zostały przydzielone przez proces, który może zostać oceniony jedynie przez działający proces wątki. |
